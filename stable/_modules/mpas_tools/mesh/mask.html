<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mpas_tools.mesh.mask &mdash; mpas_tools stable documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> mpas_tools
          </a>
              <div class="version">
                stable
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User's Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mesh_creation.html">Mesh Creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mesh_conversion.html">Mesh Conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../interpolation.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cime.html">CIME Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../config.html">Config files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../logging.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../transects.html">Transects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization.html">Visualization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Ocean Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../ocean/mesh_creation.html">Ocean Mesh Creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ocean/coastal_tools.html">Coastal Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ocean/coastline_alteration.html">Coastline Alteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ocean/moc.html">Meridional Overturning Circulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ocean/depth.html">Adding a Depth Coordinate</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Sea-ice Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../seaice/mask.html">Mask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../seaice/mesh.html">Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../seaice/partition.html">Graph partitioning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../seaice/regions.html">Region masks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../seaice/regrid.html">Regrid</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer's Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../making_changes.html">Making Changes to mpas_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../testing_changes.html">Testing Changes to mpas_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../building_docs.html">Building the Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Authors</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Main Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html#contributors">Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../versions.html">Versions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mpas_tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mpas_tools.mesh.mask</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mpas_tools.mesh.mask</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span>
<span class="kn">import</span> <span class="nn">shapely.ops</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">box</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">GeometryCollection</span>
<span class="kn">from</span> <span class="nn">shapely.strtree</span> <span class="kn">import</span> <span class="n">STRtree</span>
<span class="kn">import</span> <span class="nn">progressbar</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">from</span> <span class="nn">igraph</span> <span class="kn">import</span> <span class="n">Graph</span>

<span class="kn">from</span> <span class="nn">geometric_features</span> <span class="kn">import</span> <span class="n">read_feature_collection</span>

<span class="kn">from</span> <span class="nn">mpas_tools.transects</span> <span class="kn">import</span> <span class="n">subdivide_great_circle</span><span class="p">,</span> \
    <span class="n">lon_lat_to_cartesian</span><span class="p">,</span> <span class="n">cartesian_to_lon_lat</span>
<span class="kn">from</span> <span class="nn">mpas_tools.parallel</span> <span class="kn">import</span> <span class="n">create_pool</span>
<span class="kn">from</span> <span class="nn">mpas_tools.io</span> <span class="kn">import</span> <span class="n">write_netcdf</span>
<span class="kn">from</span> <span class="nn">mpas_tools.logging</span> <span class="kn">import</span> <span class="n">LoggingContext</span>
<span class="kn">from</span> <span class="nn">mpas_tools.cime.constants</span> <span class="kn">import</span> <span class="n">constants</span>


<div class="viewcode-block" id="compute_mpas_region_masks"><a class="viewcode-back" href="../../../generated/mpas_tools.mesh.mask.compute_mpas_region_masks.html#mpas_tools.mesh.mask.compute_mpas_region_masks">[docs]</a><span class="k">def</span> <span class="nf">compute_mpas_region_masks</span><span class="p">(</span><span class="n">dsMesh</span><span class="p">,</span> <span class="n">fcMask</span><span class="p">,</span> <span class="n">maskTypes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;vertex&#39;</span><span class="p">),</span>
                              <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunkSize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                              <span class="n">showProgress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subdivisionThreshold</span><span class="o">=</span><span class="mf">30.</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use shapely and processes to create a set of masks from a feature collection</span>
<span class="sd">    made up of regions (polygons)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dsMesh : xarray.Dataset</span>
<span class="sd">        An MPAS mesh on which the masks should be created</span>

<span class="sd">    fcMask : geometric_features.FeatureCollection</span>
<span class="sd">        A feature collection containing features to use to create the mask</span>

<span class="sd">    maskTypes : tuple of {&#39;cell&#39;, &#39;edge&#39;, &#39;vertex&#39;}, optional</span>
<span class="sd">        Which type(s) of masks to make.  Masks are created based on whether</span>
<span class="sd">        the latitude and longitude associated with each of these locations</span>
<span class="sd">        (e.g. ``dsMesh.latCell`` and ``dsMesh.lonCell`` for ``&#39;cells&#39;``) are</span>
<span class="sd">        inside or outside of the regions in ``fcMask``.</span>

<span class="sd">    logger : logging.Logger, optional</span>
<span class="sd">        A logger for the output if not stdout</span>

<span class="sd">    pool : multiprocessing.Pool, optional</span>
<span class="sd">        A pool for performing multiprocessing</span>

<span class="sd">    chunkSize : int, optional</span>
<span class="sd">        The number of cells, vertices or edges that are processed in one</span>
<span class="sd">        operation.  Experimentation has shown that 1000 is a reasonable</span>
<span class="sd">        compromise between dividing the work into sufficient subtasks to</span>
<span class="sd">        distribute the load and having sufficient work for each thread.</span>

<span class="sd">    showProgress : bool, optional</span>
<span class="sd">        Whether to show a progress bar</span>

<span class="sd">    subdivisionThreshold : float, optional</span>
<span class="sd">        A threshold in degrees (lon or lat) above which the mask region will</span>
<span class="sd">        be subdivided into smaller polygons for faster intersection checking</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dsMask : xarray.Dataset</span>
<span class="sd">        The masks</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">suffixes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="s1">&#39;Cell&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span> <span class="s1">&#39;Edge&#39;</span><span class="p">,</span> <span class="s1">&#39;vertex&#39;</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">}</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="s1">&#39;nCells&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span> <span class="s1">&#39;nEdges&#39;</span><span class="p">,</span> <span class="s1">&#39;vertex&#39;</span><span class="p">:</span> <span class="s1">&#39;nVertices&#39;</span><span class="p">}</span>

    <span class="n">dsMasks</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">maskType</span> <span class="ow">in</span> <span class="n">maskTypes</span><span class="p">:</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">suffixes</span><span class="p">[</span><span class="n">maskType</span><span class="p">]</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[</span><span class="n">maskType</span><span class="p">]</span>
        <span class="n">lonName</span> <span class="o">=</span> <span class="s1">&#39;lon</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
        <span class="n">latName</span> <span class="o">=</span> <span class="s1">&#39;lat</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dsMesh</span><span class="p">[</span><span class="n">latName</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># transform longitudes to [-180, 180)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dsMesh</span><span class="p">[</span><span class="n">lonName</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">,</span>
                        <span class="mf">360.</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.</span>

        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Computing </span><span class="si">{}</span><span class="s1"> masks:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">maskType</span><span class="p">))</span>

        <span class="c1"># create shapely geometry for lon and lat</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)]</span>
        <span class="n">regionNames</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">nChar</span> <span class="o">=</span> <span class="n">_compute_region_masks</span><span class="p">(</span>
            <span class="n">fcMask</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">,</span> <span class="n">showProgress</span><span class="p">,</span>
            <span class="n">subdivisionThreshold</span><span class="p">)</span>

        <span class="n">nPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Adding masks to dataset...&#39;</span><span class="p">)</span>
        <span class="n">nRegions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">regionNames</span><span class="p">)</span>
        <span class="c1"># create a new data array for masks</span>
        <span class="n">masksVarName</span> <span class="o">=</span> <span class="s1">&#39;region</span><span class="si">{}</span><span class="s1">Masks&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
        <span class="n">dsMasks</span><span class="p">[</span><span class="n">masksVarName</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="s1">&#39;nRegions&#39;</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nPoints</span><span class="p">,</span> <span class="n">nRegions</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRegions</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">dsMasks</span><span class="p">[</span><span class="n">masksVarName</span><span class="p">][:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;regionNames&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dsMasks</span><span class="p">:</span>
            <span class="c1"># create a new data array for mask names</span>
            <span class="n">dsMasks</span><span class="p">[</span><span class="s1">&#39;regionNames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;nRegions&#39;</span><span class="p">,),</span>
                                      <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nRegions</span><span class="p">,),</span>
                                                  <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|S</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nChar</span><span class="p">)))</span>

            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRegions</span><span class="p">):</span>
                <span class="n">dsMasks</span><span class="p">[</span><span class="s1">&#39;regionNames&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">regionNames</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">propertyName</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">propertyName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dsMasks</span><span class="p">:</span>
                <span class="n">dsMasks</span><span class="p">[</span><span class="n">propertyName</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;nRegions&#39;</span><span class="p">,),</span>
                                         <span class="n">properties</span><span class="p">[</span><span class="n">propertyName</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Done.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dsMasks</span></div>


<span class="k">def</span> <span class="nf">entry_point_compute_mpas_region_masks</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Entry point for ``compute_mpas_region_masks()``&quot;&quot;&quot;</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-m&quot;</span><span class="p">,</span> <span class="s2">&quot;--mesh_file_name&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;mesh_file_name&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An MPAS mesh file&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-g&quot;</span><span class="p">,</span> <span class="s2">&quot;--geojson_file_name&quot;</span><span class="p">,</span>
                        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;geojson_file_name&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An Geojson file containing mask regions&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="s2">&quot;--mask_file_name&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;mask_file_name&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An output MPAS region masks file&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-t&quot;</span><span class="p">,</span> <span class="s2">&quot;--mask_types&quot;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;mask_types&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Which type(s) of masks to make: cell, edge or &quot;</span>
                             <span class="s2">&quot;vertex.  Default is cell and vertex.&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;--chunk_size&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;chunk_size&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The number of cells, vertices or edges that are &quot;</span>
                             <span class="s2">&quot;processed in one operation&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--show_progress&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;show_progress&quot;</span><span class="p">,</span>
                        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Whether to show a progress bar&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="s2">&quot;--subdivision&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;subdivision&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;A threshold in degrees (lon or lat) above which &quot;</span>
                             <span class="s2">&quot;the mask region will be subdivided into smaller &quot;</span>
                             <span class="s2">&quot;polygons for faster intersection checking&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--process_count&quot;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;process_count&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The number of processes to use to compute masks.  The &quot;</span>
             <span class="s2">&quot;default is to use all available cores&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--multiprocessing_method&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;multiprocessing_method&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s1">&#39;forkserver&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The multiprocessing method use for python mask creation &quot;</span>
             <span class="s2">&quot;(&#39;fork&#39;, &#39;spawn&#39; or &#39;forkserver&#39;)&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--format&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;NetCDF file format&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--engine&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;engine&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;NetCDF output engine&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">dsMesh</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">mesh_file_name</span><span class="p">,</span> <span class="n">decode_cf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">decode_times</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fcMask</span> <span class="o">=</span> <span class="n">read_feature_collection</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">geojson_file_name</span><span class="p">)</span>

    <span class="n">pool</span> <span class="o">=</span> <span class="n">create_pool</span><span class="p">(</span><span class="n">process_count</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">process_count</span><span class="p">,</span>
                       <span class="n">method</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">multiprocessing_method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">mask_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span><span class="o">.</span><span class="n">mask_types</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;vertex&#39;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">LoggingContext</span><span class="p">(</span><span class="s1">&#39;compute_mpas_region_masks&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">dsMasks</span> <span class="o">=</span> <span class="n">compute_mpas_region_masks</span><span class="p">(</span>
            <span class="n">dsMesh</span><span class="o">=</span><span class="n">dsMesh</span><span class="p">,</span> <span class="n">fcMask</span><span class="o">=</span><span class="n">fcMask</span><span class="p">,</span> <span class="n">maskTypes</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">mask_types</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="n">showProgress</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">show_progress</span><span class="p">,</span>
            <span class="n">subdivisionThreshold</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">subdivision</span><span class="p">)</span>

    <span class="n">write_netcdf</span><span class="p">(</span><span class="n">dsMasks</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">mask_file_name</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
                 <span class="n">engine</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">engine</span><span class="p">)</span>


<div class="viewcode-block" id="compute_mpas_transect_masks"><a class="viewcode-back" href="../../../generated/mpas_tools.mesh.mask.compute_mpas_transect_masks.html#mpas_tools.mesh.mask.compute_mpas_transect_masks">[docs]</a><span class="k">def</span> <span class="nf">compute_mpas_transect_masks</span><span class="p">(</span><span class="n">dsMesh</span><span class="p">,</span> <span class="n">fcMask</span><span class="p">,</span> <span class="n">earthRadius</span><span class="p">,</span>
                                <span class="n">maskTypes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="s1">&#39;vertex&#39;</span><span class="p">),</span>
                                <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunkSize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                <span class="n">showProgress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subdivisionResolution</span><span class="o">=</span><span class="mf">10e3</span><span class="p">,</span>
                                <span class="n">addEdgeSign</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use shapely and processes to create a set of masks from a feature</span>
<span class="sd">    collection made up of transects (line strings)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dsMesh : xarray.Dataset</span>
<span class="sd">        An MPAS mesh on which the masks should be created</span>

<span class="sd">    fcMask : geometric_features.FeatureCollection</span>
<span class="sd">        A feature collection containing features to use to create the mask</span>

<span class="sd">    earthRadius : float</span>
<span class="sd">        The radius of the earth in meters</span>

<span class="sd">    maskTypes : tuple of {&#39;cell&#39;, &#39;edge&#39;, &#39;vertex&#39;}, optional</span>
<span class="sd">        Which type(s) of masks to make.  Masks are created based on whether</span>
<span class="sd">        the latitude and longitude associated with each of these locations</span>
<span class="sd">        (e.g. ``dsMesh.latCell`` and ``dsMesh.lonCell`` for ``&#39;cells&#39;``) are</span>
<span class="sd">        inside or outside of the transects in ``fcMask``.</span>

<span class="sd">    logger : logging.Logger, optional</span>
<span class="sd">        A logger for the output if not stdout</span>

<span class="sd">    pool : multiprocessing.Pool, optional</span>
<span class="sd">        A pool for performing multiprocessing</span>

<span class="sd">    chunkSize : int, optional</span>
<span class="sd">        The number of cells, vertices or edges that are processed in one</span>
<span class="sd">        operation.  Experimentation has shown that 1000 is a reasonable</span>
<span class="sd">        compromise between dividing the work into sufficient subtasks to</span>
<span class="sd">        distribute the load and having sufficient work for each thread.</span>

<span class="sd">    showProgress : bool, optional</span>
<span class="sd">        Whether to show a progress bar</span>

<span class="sd">    subdivisionResolution : float, optional</span>
<span class="sd">        The maximum resolution (in meters) of segments in a transect.  If a</span>
<span class="sd">        transect is too coarse, it will be subdivided.  Pass ``None`` for no</span>
<span class="sd">        subdivision.</span>

<span class="sd">    addEdgeSign : bool, optional</span>
<span class="sd">        Whether to add the ``edgeSign`` variable, which requires significant</span>
<span class="sd">        extra computation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dsMask : xarray.Dataset</span>
<span class="sd">        The masks</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">suffixes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="s1">&#39;Cell&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span> <span class="s1">&#39;Edge&#39;</span><span class="p">,</span> <span class="s1">&#39;vertex&#39;</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">}</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="s1">&#39;nCells&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span> <span class="s1">&#39;nEdges&#39;</span><span class="p">,</span> <span class="s1">&#39;vertex&#39;</span><span class="p">:</span> <span class="s1">&#39;nVertices&#39;</span><span class="p">}</span>

    <span class="n">dsMasks</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">maskType</span> <span class="ow">in</span> <span class="n">maskTypes</span><span class="p">:</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">suffixes</span><span class="p">[</span><span class="n">maskType</span><span class="p">]</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[</span><span class="n">maskType</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Computing </span><span class="si">{}</span><span class="s1"> masks:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">maskType</span><span class="p">))</span>

        <span class="n">polygons</span><span class="p">,</span> <span class="n">nPolygons</span><span class="p">,</span> <span class="n">duplicatePolygons</span> <span class="o">=</span> \
            <span class="n">_get_polygons</span><span class="p">(</span><span class="n">dsMesh</span><span class="p">,</span> <span class="n">maskType</span><span class="p">)</span>
        <span class="n">transectNames</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">nChar</span><span class="p">,</span> <span class="n">shapes</span> <span class="o">=</span> \
            <span class="n">_compute_transect_masks</span><span class="p">(</span><span class="n">fcMask</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">,</span>
                                    <span class="n">showProgress</span><span class="p">,</span> <span class="n">subdivisionResolution</span><span class="p">,</span>
                                    <span class="n">earthRadius</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">addEdgeSign</span> <span class="ow">and</span> <span class="n">maskType</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Adding masks and edge signs to dataset...&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Adding masks to dataset...&#39;</span><span class="p">)</span>
        <span class="n">nTransects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">transectNames</span><span class="p">)</span>
        <span class="c1"># create a new data array for masks</span>
        <span class="n">masksVarName</span> <span class="o">=</span> <span class="s1">&#39;transect</span><span class="si">{}</span><span class="s1">Masks&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
        <span class="n">dsMasks</span><span class="p">[</span><span class="n">masksVarName</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="s1">&#39;nTransects&#39;</span><span class="p">),</span>
             <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nPolygons</span><span class="p">,</span> <span class="n">nTransects</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">addEdgeSign</span> <span class="ow">and</span> <span class="n">maskType</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
            <span class="n">dsMasks</span><span class="p">[</span><span class="s1">&#39;transectEdgeMaskSigns&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="s1">&#39;nTransects&#39;</span><span class="p">),</span>
                 <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nPolygons</span><span class="p">,</span> <span class="n">nTransects</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nTransects</span><span class="p">):</span>
            <span class="n">maskAndDuplicates</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">maskAndDuplicates</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nPolygons</span><span class="p">]</span>

            <span class="n">mask</span><span class="p">[</span><span class="n">duplicatePolygons</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">numpy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">duplicatePolygons</span><span class="p">],</span>
                                 <span class="n">maskAndDuplicates</span><span class="p">[</span><span class="n">nPolygons</span><span class="p">:])</span>
            <span class="n">dsMasks</span><span class="p">[</span><span class="n">masksVarName</span><span class="p">][:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">addEdgeSign</span> <span class="ow">and</span> <span class="n">maskType</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">transectNames</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="n">dsMasks</span><span class="p">[</span><span class="s1">&#39;transectEdgeMaskSigns&#39;</span><span class="p">][:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">_compute_edge_sign</span><span class="p">(</span><span class="n">dsMesh</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">shapes</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="k">if</span> <span class="s1">&#39;transectNames&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dsMasks</span><span class="p">:</span>
            <span class="c1"># create a new data array for mask names</span>
            <span class="n">dsMasks</span><span class="p">[</span><span class="s1">&#39;transectNames&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">((</span><span class="s1">&#39;nTransects&#39;</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nTransects</span><span class="p">,),</span>
                                              <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|S</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nChar</span><span class="p">)))</span>

            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nTransects</span><span class="p">):</span>
                <span class="n">dsMasks</span><span class="p">[</span><span class="s1">&#39;transectNames&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">transectNames</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">propertyName</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">propertyName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dsMasks</span><span class="p">:</span>
                <span class="n">dsMasks</span><span class="p">[</span><span class="n">propertyName</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;nTransects&#39;</span><span class="p">,),</span>
                                         <span class="n">properties</span><span class="p">[</span><span class="n">propertyName</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Done.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dsMasks</span></div>


<span class="k">def</span> <span class="nf">entry_point_compute_mpas_transect_masks</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Entry point for ``compute_mpas_transect_masks()``&quot;&quot;&quot;</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-m&quot;</span><span class="p">,</span> <span class="s2">&quot;--mesh_file_name&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;mesh_file_name&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An MPAS mesh file&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-g&quot;</span><span class="p">,</span> <span class="s2">&quot;--geojson_file_name&quot;</span><span class="p">,</span>
                        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;geojson_file_name&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An Geojson file containing transects&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="s2">&quot;--mask_file_name&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;mask_file_name&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An output MPAS transect masks file&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-t&quot;</span><span class="p">,</span> <span class="s2">&quot;--mask_types&quot;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;mask_types&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Which type(s) of masks to make: cell, edge or &quot;</span>
                             <span class="s2">&quot;vertex.  Default is cell, edge and vertex.&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;--chunk_size&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;chunk_size&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The number of cells, vertices or edges that are &quot;</span>
                             <span class="s2">&quot;processed in one operation&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--show_progress&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;show_progress&quot;</span><span class="p">,</span>
                        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Whether to show a progress bar&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="s2">&quot;--subdivision&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;subdivision&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The maximum resolution (in meters) of segments &quot;</span>
                             <span class="s2">&quot;in a transect.  If a transect is too coarse, it &quot;</span>
                             <span class="s2">&quot;will be subdivided.  Default is no subdivision.&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--process_count&quot;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;process_count&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The number of processes to use to compute masks.  The &quot;</span>
             <span class="s2">&quot;default is to use all available cores&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--multiprocessing_method&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;multiprocessing_method&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s1">&#39;forkserver&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The multiprocessing method use for python mask creation &quot;</span>
             <span class="s2">&quot;(&#39;fork&#39;, &#39;spawn&#39; or &#39;forkserver&#39;)&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--add_edge_sign&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;add_edge_sign&quot;</span><span class="p">,</span>
                        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Whether to add the transectEdgeMaskSigns &quot;</span>
                             <span class="s2">&quot;variable&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--format&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;NetCDF file format&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--engine&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;engine&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;NetCDF output engine&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">dsMesh</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">mesh_file_name</span><span class="p">,</span> <span class="n">decode_cf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">decode_times</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fcMask</span> <span class="o">=</span> <span class="n">read_feature_collection</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">geojson_file_name</span><span class="p">)</span>

    <span class="n">pool</span> <span class="o">=</span> <span class="n">create_pool</span><span class="p">(</span><span class="n">process_count</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">process_count</span><span class="p">,</span>
                       <span class="n">method</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">multiprocessing_method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">mask_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span><span class="o">.</span><span class="n">mask_types</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="s1">&#39;vertex&#39;</span><span class="p">)</span>

    <span class="n">earth_radius</span> <span class="o">=</span> <span class="n">constants</span><span class="p">[</span><span class="s1">&#39;SHR_CONST_REARTH&#39;</span><span class="p">]</span>

    <span class="k">with</span> <span class="n">LoggingContext</span><span class="p">(</span><span class="s1">&#39;compute_mpas_transect_masks&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">dsMasks</span> <span class="o">=</span> <span class="n">compute_mpas_transect_masks</span><span class="p">(</span>
            <span class="n">dsMesh</span><span class="o">=</span><span class="n">dsMesh</span><span class="p">,</span> <span class="n">fcMask</span><span class="o">=</span><span class="n">fcMask</span><span class="p">,</span> <span class="n">earthRadius</span><span class="o">=</span><span class="n">earth_radius</span><span class="p">,</span>
            <span class="n">maskTypes</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">mask_types</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="n">pool</span><span class="p">,</span>
            <span class="n">chunkSize</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">showProgress</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">show_progress</span><span class="p">,</span>
            <span class="n">subdivisionResolution</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">subdivision</span><span class="p">,</span>
            <span class="n">addEdgeSign</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">add_edge_sign</span><span class="p">)</span>

    <span class="n">write_netcdf</span><span class="p">(</span><span class="n">dsMasks</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">mask_file_name</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
                 <span class="n">engine</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">engine</span><span class="p">)</span>


<div class="viewcode-block" id="compute_mpas_flood_fill_mask"><a class="viewcode-back" href="../../../generated/mpas_tools.mesh.mask.compute_mpas_flood_fill_mask.html#mpas_tools.mesh.mask.compute_mpas_flood_fill_mask">[docs]</a><span class="k">def</span> <span class="nf">compute_mpas_flood_fill_mask</span><span class="p">(</span><span class="n">dsMesh</span><span class="p">,</span> <span class="n">fcSeed</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workers</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flood fill from the given set of seed points to create a contiguous mask.</span>
<span class="sd">    The flood fill operates using cellsOnCell, starting from the cells</span>
<span class="sd">    whose centers are closest to the seed points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dsMesh : xarray.Dataset</span>
<span class="sd">        An MPAS mesh on which the masks should be created</span>

<span class="sd">    fcSeed : geometric_features.FeatureCollection</span>
<span class="sd">        A feature collection containing points at which to start the flood fill</span>

<span class="sd">    logger : logging.Logger, optional</span>
<span class="sd">        A logger for the output if not stdout</span>

<span class="sd">    workers : int, optional</span>
<span class="sd">        The number of threads used for finding nearest neighbors.  The default</span>
<span class="sd">        is all available threads (``workers=-1``)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dsMask : xarray.Dataset</span>
<span class="sd">        The masks</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dsMasks</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>

    <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dsMesh</span><span class="o">.</span><span class="n">latCell</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="c1"># transform longitudes to [-180, 180)</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dsMesh</span><span class="o">.</span><span class="n">lonCell</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">,</span>
                    <span class="mf">360.</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.</span>

    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Computing flood fill mask on cells:&#39;</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">_compute_seed_mask</span><span class="p">(</span><span class="n">fcSeed</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">workers</span><span class="p">)</span>

    <span class="n">cellsOnCell</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">cellsOnCell</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">_flood_fill_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cellsOnCell</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Adding masks to dataset...&#39;</span><span class="p">)</span>
    <span class="c1"># create a new data array for the mask</span>
    <span class="n">masksVarName</span> <span class="o">=</span> <span class="s1">&#39;cellSeedMask&#39;</span>
    <span class="n">dsMasks</span><span class="p">[</span><span class="n">masksVarName</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;nCells&#39;</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Done.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dsMasks</span></div>


<span class="k">def</span> <span class="nf">entry_point_compute_mpas_flood_fill_mask</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Entry point for ``compute_mpas_flood_fill_mask()``&quot;&quot;&quot;</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-m&quot;</span><span class="p">,</span> <span class="s2">&quot;--mesh_file_name&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;mesh_file_name&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An MPAS mesh file&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-g&quot;</span><span class="p">,</span> <span class="s2">&quot;--geojson_file_name&quot;</span><span class="p">,</span>
                        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;geojson_file_name&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An Geojson file containing points at which to &quot;</span>
                             <span class="s2">&quot;start the flood fill&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="s2">&quot;--mask_file_name&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;mask_file_name&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An output MPAS region masks file&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--format&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;NetCDF file format&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--engine&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;engine&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;NetCDF output engine&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">dsMesh</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">mesh_file_name</span><span class="p">,</span> <span class="n">decode_cf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">decode_times</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fcSeed</span> <span class="o">=</span> <span class="n">read_feature_collection</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">geojson_file_name</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">LoggingContext</span><span class="p">(</span><span class="s1">&#39;compute_mpas_flood_fill_mask&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">dsMasks</span> <span class="o">=</span> <span class="n">compute_mpas_flood_fill_mask</span><span class="p">(</span>
            <span class="n">dsMesh</span><span class="o">=</span><span class="n">dsMesh</span><span class="p">,</span> <span class="n">fcSeed</span><span class="o">=</span><span class="n">fcSeed</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">)</span>

    <span class="n">write_netcdf</span><span class="p">(</span><span class="n">dsMasks</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">mask_file_name</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
                 <span class="n">engine</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">engine</span><span class="p">)</span>


<div class="viewcode-block" id="compute_lon_lat_region_masks"><a class="viewcode-back" href="../../../generated/mpas_tools.mesh.mask.compute_lon_lat_region_masks.html#mpas_tools.mesh.mask.compute_lon_lat_region_masks">[docs]</a><span class="k">def</span> <span class="nf">compute_lon_lat_region_masks</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">fcMask</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">chunkSize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">showProgress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">subdivisionThreshold</span><span class="o">=</span><span class="mf">30.</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use shapely and processes to create a set of masks from a feature</span>
<span class="sd">    collection made up of regions (polygons) on a tensor lon/lat grid</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lon : numpy.ndarray</span>
<span class="sd">        A 1D array of longitudes in degrees between -180 and 180</span>

<span class="sd">    lat : numpy.ndarray</span>
<span class="sd">        A 1D array of latitudes in degrees between -90 and 90</span>

<span class="sd">    fcMask : geometric_features.FeatureCollection</span>
<span class="sd">        A feature collection containing features to use to create the mask</span>

<span class="sd">    logger : logging.Logger, optional</span>
<span class="sd">        A logger for the output if not stdout</span>

<span class="sd">    pool : multiprocessing.Pool, optional</span>
<span class="sd">        A pool for performing multiprocessing</span>

<span class="sd">    chunkSize : int, optional</span>
<span class="sd">        The number of cells, vertices or edges that are processed in one</span>
<span class="sd">        operation.  Experimentation has shown that 1000 is a reasonable</span>
<span class="sd">        compromise between dividing the work into sufficient subtasks to</span>
<span class="sd">        distribute the load and having sufficient work for each thread.</span>

<span class="sd">    showProgress : bool, optional</span>
<span class="sd">        Whether to show a progress bar</span>

<span class="sd">    subdivisionThreshold : float, optional</span>
<span class="sd">        A threshold in degrees (lon or lat) above which the mask region will</span>
<span class="sd">        be subdivided into smaller polygons for faster intersection checking</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dsMask : xarray.Dataset</span>
<span class="sd">        The masks</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dsMasks</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>

    <span class="n">Lon</span><span class="p">,</span> <span class="n">Lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">Lon</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">Lon</span> <span class="o">=</span> <span class="n">Lon</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">Lat</span> <span class="o">=</span> <span class="n">Lat</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="c1"># create shapely geometry for lon and lat</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Lon</span><span class="p">,</span> <span class="n">Lat</span><span class="p">)]</span>
    <span class="n">regionNames</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">nChar</span> <span class="o">=</span> <span class="n">_compute_region_masks</span><span class="p">(</span>
        <span class="n">fcMask</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">,</span> <span class="n">showProgress</span><span class="p">,</span>
        <span class="n">subdivisionThreshold</span><span class="p">)</span>

    <span class="n">nlon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
    <span class="n">nlat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Adding masks to dataset...&#39;</span><span class="p">)</span>
    <span class="n">nRegions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">regionNames</span><span class="p">)</span>
    <span class="c1"># create a new data array for masks</span>
    <span class="n">masksVarName</span> <span class="o">=</span> <span class="s1">&#39;regionMasks&#39;</span>
    <span class="n">dsMasks</span><span class="p">[</span><span class="n">masksVarName</span><span class="p">]</span> <span class="o">=</span> \
        <span class="p">((</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;nRegions&#39;</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">,</span> <span class="n">nRegions</span><span class="p">),</span>
                                                 <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRegions</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">dsMasks</span><span class="p">[</span><span class="n">masksVarName</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># create a new data array for mask names</span>
    <span class="n">dsMasks</span><span class="p">[</span><span class="s1">&#39;regionNames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;nRegions&#39;</span><span class="p">,),</span>
                              <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nRegions</span><span class="p">,),</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|S</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nChar</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRegions</span><span class="p">):</span>
        <span class="n">dsMasks</span><span class="p">[</span><span class="s1">&#39;regionNames&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">regionNames</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">propertyName</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">propertyName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dsMasks</span><span class="p">:</span>
            <span class="n">dsMasks</span><span class="p">[</span><span class="n">propertyName</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;nRegions&#39;</span><span class="p">,),</span>
                                     <span class="n">properties</span><span class="p">[</span><span class="n">propertyName</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Done.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dsMasks</span></div>


<span class="k">def</span> <span class="nf">entry_point_compute_lon_lat_region_masks</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Entry point for ``compute_lon_lat_region_masks()``&quot;&quot;&quot;</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-i&quot;</span><span class="p">,</span> <span class="s2">&quot;--grid_file_name&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;grid_file_name&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An input lon/lat grid file&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--lon&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The name of the longitude coordinate&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--lat&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The name of the latitude coordinate&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-g&quot;</span><span class="p">,</span> <span class="s2">&quot;--geojson_file_name&quot;</span><span class="p">,</span>
                        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;geojson_file_name&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An Geojson file containing mask regions&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="s2">&quot;--mask_file_name&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;mask_file_name&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An output MPAS region masks file&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;--chunk_size&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;chunk_size&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The number of grid points that are &quot;</span>
                             <span class="s2">&quot;processed in one operation&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--show_progress&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;show_progress&quot;</span><span class="p">,</span>
                        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Whether to show a progress bar&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="s2">&quot;--subdivision&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;subdivision&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;A threshold in degrees (lon or lat) above which &quot;</span>
                             <span class="s2">&quot;the mask region will be subdivided into smaller &quot;</span>
                             <span class="s2">&quot;polygons for faster intersection checking&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--process_count&quot;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;process_count&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The number of processes to use to compute masks.  The &quot;</span>
             <span class="s2">&quot;default is to use all available cores&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--multiprocessing_method&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;multiprocessing_method&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s1">&#39;forkserver&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The multiprocessing method use for python mask creation &quot;</span>
             <span class="s2">&quot;(&#39;fork&#39;, &#39;spawn&#39; or &#39;forkserver&#39;)&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--format&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;NetCDF file format&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--engine&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;engine&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;NetCDF output engine&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">dsGrid</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">grid_file_name</span><span class="p">,</span> <span class="n">decode_cf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">decode_times</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">dsGrid</span><span class="p">[</span><span class="n">args</span><span class="o">.</span><span class="n">lon</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">dsGrid</span><span class="p">[</span><span class="n">args</span><span class="o">.</span><span class="n">lat</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="n">fcMask</span> <span class="o">=</span> <span class="n">read_feature_collection</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">geojson_file_name</span><span class="p">)</span>

    <span class="n">pool</span> <span class="o">=</span> <span class="n">create_pool</span><span class="p">(</span><span class="n">process_count</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">process_count</span><span class="p">,</span>
                       <span class="n">method</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">multiprocessing_method</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">LoggingContext</span><span class="p">(</span><span class="s1">&#39;compute_lon_lat_region_masks&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">dsMasks</span> <span class="o">=</span> <span class="n">compute_lon_lat_region_masks</span><span class="p">(</span>
            <span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">fcMask</span><span class="o">=</span><span class="n">fcMask</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="n">pool</span><span class="p">,</span>
            <span class="n">chunkSize</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">showProgress</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">show_progress</span><span class="p">,</span>
            <span class="n">subdivisionThreshold</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">subdivision</span><span class="p">)</span>

    <span class="n">write_netcdf</span><span class="p">(</span><span class="n">dsMasks</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">mask_file_name</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
                 <span class="n">engine</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">engine</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">compute_projection_grid_region_masks</span><span class="p">(</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">fcMask</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunkSize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">showProgress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subdivisionThreshold</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span> <span class="n">xdim</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">ydim</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use shapely and processes to create a set of masks from a feature</span>
<span class="sd">    collection made up of regions (polygons) on a projection grid such as</span>
<span class="sd">    a polar-stereographic grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lon : numpy.ndarray</span>
<span class="sd">        A 2D array of longitudes in degrees between -180 and 180</span>

<span class="sd">    lat : numpy.ndarray</span>
<span class="sd">        A 2D array of latitudes in degrees between -90 and 90</span>

<span class="sd">    fcMask : geometric_features.FeatureCollection</span>
<span class="sd">        A feature collection containing features to use to create the mask</span>

<span class="sd">    logger : logging.Logger, optional</span>
<span class="sd">        A logger for the output if not stdout</span>

<span class="sd">    pool : multiprocessing.Pool, optional</span>
<span class="sd">        A pool for performing multiprocessing</span>

<span class="sd">    chunkSize : int, optional</span>
<span class="sd">        The number of cells, vertices or edges that are processed in one</span>
<span class="sd">        operation.  Experimentation has shown that 1000 is a reasonable</span>
<span class="sd">        compromise between dividing the work into sufficient subtasks to</span>
<span class="sd">        distribute the load and having sufficient work for each thread.</span>

<span class="sd">    showProgress : bool, optional</span>
<span class="sd">        Whether to show a progress bar</span>

<span class="sd">    subdivisionThreshold : float, optional</span>
<span class="sd">        A threshold in degrees (lon or lat) above which the mask region will</span>
<span class="sd">        be subdivided into smaller polygons for faster intersection checking</span>

<span class="sd">    xdim : str, optional</span>
<span class="sd">        The name of the x dimension</span>

<span class="sd">    ydim : str, optional</span>
<span class="sd">        The name of the y dimension</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dsMask : xarray.Dataset</span>
<span class="sd">        The masks</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dsMasks</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>

    <span class="c1"># make sure -180 &lt;= lon &lt; 180</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lon</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">,</span> <span class="mf">360.</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.</span>

    <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">lon</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># create shapely geometry for lon and lat</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span>
              <span class="nb">zip</span><span class="p">(</span><span class="n">lon</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">lat</span><span class="o">.</span><span class="n">ravel</span><span class="p">())]</span>
    <span class="n">regionNames</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">nChar</span> <span class="o">=</span> <span class="n">_compute_region_masks</span><span class="p">(</span>
        <span class="n">fcMask</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">,</span> <span class="n">showProgress</span><span class="p">,</span>
        <span class="n">subdivisionThreshold</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Adding masks to dataset...&#39;</span><span class="p">)</span>
    <span class="n">nRegions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">regionNames</span><span class="p">)</span>
    <span class="c1"># create a new data array for masks</span>
    <span class="n">masksVarName</span> <span class="o">=</span> <span class="s1">&#39;regionMasks&#39;</span>
    <span class="n">dsMasks</span><span class="p">[</span><span class="n">masksVarName</span><span class="p">]</span> <span class="o">=</span> \
        <span class="p">((</span><span class="n">ydim</span><span class="p">,</span> <span class="n">xdim</span><span class="p">,</span> <span class="s1">&#39;nRegions&#39;</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">nRegions</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRegions</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">dsMasks</span><span class="p">[</span><span class="n">masksVarName</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># create a new data array for mask names</span>
    <span class="n">dsMasks</span><span class="p">[</span><span class="s1">&#39;regionNames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;nRegions&#39;</span><span class="p">,),</span>
                              <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nRegions</span><span class="p">,),</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|S</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nChar</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRegions</span><span class="p">):</span>
        <span class="n">dsMasks</span><span class="p">[</span><span class="s1">&#39;regionNames&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">regionNames</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">propertyName</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">propertyName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dsMasks</span><span class="p">:</span>
            <span class="n">dsMasks</span><span class="p">[</span><span class="n">propertyName</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;nRegions&#39;</span><span class="p">,),</span>
                                     <span class="n">properties</span><span class="p">[</span><span class="n">propertyName</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Done.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dsMasks</span>


<span class="k">def</span> <span class="nf">entry_point_compute_projection_grid_region_masks</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Entry point for ``compute_projection_grid_region_masks()``&quot;&quot;&quot;</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-i&quot;</span><span class="p">,</span> <span class="s2">&quot;--grid_file_name&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;grid_file_name&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An input lon/lat grid file&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--lon&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The name of the 2D longitude coordinate&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--lat&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The name of the 2D latitude coordinate&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-g&quot;</span><span class="p">,</span> <span class="s2">&quot;--geojson_file_name&quot;</span><span class="p">,</span>
                        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;geojson_file_name&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An Geojson file containing mask regions&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="s2">&quot;--mask_file_name&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;mask_file_name&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;An output MPAS region masks file&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;--chunk_size&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;chunk_size&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The number of grid points that are &quot;</span>
                             <span class="s2">&quot;processed in one operation&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--show_progress&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;show_progress&quot;</span><span class="p">,</span>
                        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Whether to show a progress bar&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="s2">&quot;--subdivision&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;subdivision&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;A threshold in degrees (lon or lat) above which &quot;</span>
                             <span class="s2">&quot;the mask region will be subdivided into smaller &quot;</span>
                             <span class="s2">&quot;polygons for faster intersection checking&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--process_count&quot;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;process_count&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The number of processes to use to compute masks.  The &quot;</span>
             <span class="s2">&quot;default is to use all available cores&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--multiprocessing_method&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;multiprocessing_method&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s1">&#39;forkserver&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The multiprocessing method use for python mask creation &quot;</span>
             <span class="s2">&quot;(&#39;fork&#39;, &#39;spawn&#39; or &#39;forkserver&#39;)&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--format&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;NetCDF file format&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--engine&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;engine&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;NetCDF output engine&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">dsGrid</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">grid_file_name</span><span class="p">,</span> <span class="n">decode_cf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">decode_times</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">dsGrid</span><span class="p">[</span><span class="n">args</span><span class="o">.</span><span class="n">lon</span><span class="p">]</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">dsGrid</span><span class="p">[</span><span class="n">args</span><span class="o">.</span><span class="n">lat</span><span class="p">]</span>

    <span class="n">ydim</span><span class="p">,</span> <span class="n">xdim</span> <span class="o">=</span> <span class="n">lon</span><span class="o">.</span><span class="n">dims</span>

    <span class="n">fcMask</span> <span class="o">=</span> <span class="n">read_feature_collection</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">geojson_file_name</span><span class="p">)</span>

    <span class="n">pool</span> <span class="o">=</span> <span class="n">create_pool</span><span class="p">(</span><span class="n">process_count</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">process_count</span><span class="p">,</span>
                       <span class="n">method</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">multiprocessing_method</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">LoggingContext</span><span class="p">(</span><span class="s1">&#39;compute_lon_lat_region_masks&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">dsMasks</span> <span class="o">=</span> <span class="n">compute_projection_grid_region_masks</span><span class="p">(</span>
            <span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">fcMask</span><span class="o">=</span><span class="n">fcMask</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="n">pool</span><span class="o">=</span><span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="n">showProgress</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">show_progress</span><span class="p">,</span>
            <span class="n">subdivisionThreshold</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">subdivision</span><span class="p">,</span> <span class="n">xdim</span><span class="o">=</span><span class="n">xdim</span><span class="p">,</span> <span class="n">ydim</span><span class="o">=</span><span class="n">ydim</span><span class="p">)</span>

    <span class="n">write_netcdf</span><span class="p">(</span><span class="n">dsMasks</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">mask_file_name</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
                 <span class="n">engine</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">engine</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_compute_mask_from_shapes</span><span class="p">(</span><span class="n">shapes1</span><span class="p">,</span> <span class="n">shapes2</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">,</span>
                              <span class="n">showProgress</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If multiprocessing, break shapes2 into chunks and use multiprocessing to</span>
<span class="sd">    apply the given function one chunk at a time</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nShapes2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">shapes1</span><span class="p">,</span> <span class="n">shapes2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nChunks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nShapes2</span> <span class="o">/</span> <span class="n">chunkSize</span><span class="p">))</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">iChunk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nChunks</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">iChunk</span> <span class="o">*</span> <span class="n">chunkSize</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">iChunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunkSize</span><span class="p">,</span> <span class="n">nShapes2</span><span class="p">)</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapes2</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

        <span class="n">partial_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">shapes1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">showProgress</span><span class="p">:</span>
            <span class="n">widgets</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;    &#39;</span><span class="p">,</span> <span class="n">progressbar</span><span class="o">.</span><span class="n">Percentage</span><span class="p">(),</span> <span class="s1">&#39; &#39;</span><span class="p">,</span>
                       <span class="n">progressbar</span><span class="o">.</span><span class="n">Bar</span><span class="p">(),</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">progressbar</span><span class="o">.</span><span class="n">ETA</span><span class="p">()]</span>
            <span class="n">bar</span> <span class="o">=</span> <span class="n">progressbar</span><span class="o">.</span><span class="n">ProgressBar</span><span class="p">(</span><span class="n">widgets</span><span class="o">=</span><span class="n">widgets</span><span class="p">,</span>
                                          <span class="n">maxval</span><span class="o">=</span><span class="n">nChunks</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bar</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nShapes2</span><span class="p">,),</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iChunk</span><span class="p">,</span> <span class="n">maskChunk</span> <span class="ow">in</span> \
                <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">partial_func</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)):</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">iChunk</span><span class="p">]:</span><span class="n">indices</span><span class="p">[</span><span class="n">iChunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">maskChunk</span>
            <span class="k">if</span> <span class="n">showProgress</span><span class="p">:</span>
                <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">iChunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">showProgress</span><span class="p">:</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mask</span>


<span class="k">def</span> <span class="nf">_get_region_names_and_properties</span><span class="p">(</span><span class="n">fc</span><span class="p">):</span>
    <span class="n">regionNames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">fc</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
        <span class="n">regionNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">propertyNames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">fc</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">propertyName</span> <span class="ow">in</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">propertyName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;author&#39;</span><span class="p">,</span> <span class="s1">&#39;tags&#39;</span><span class="p">,</span> <span class="s1">&#39;component&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;object&#39;</span><span class="p">]:</span>
                <span class="n">propertyNames</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">propertyName</span><span class="p">)</span>

    <span class="n">properties</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">propertyName</span> <span class="ow">in</span> <span class="n">propertyNames</span><span class="p">:</span>
        <span class="n">properties</span><span class="p">[</span><span class="n">propertyName</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">fc</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">propertyName</span> <span class="ow">in</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]:</span>
                <span class="n">propertyVal</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="n">propertyName</span><span class="p">]</span>
                <span class="n">properties</span><span class="p">[</span><span class="n">propertyName</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">propertyVal</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">properties</span><span class="p">[</span><span class="n">propertyName</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">regionNames</span><span class="p">,</span> <span class="n">properties</span>


<span class="k">def</span> <span class="nf">_compute_region_masks</span><span class="p">(</span><span class="n">fcMask</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">,</span>
                          <span class="n">showProgress</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a region mask file from the given mesh and geojson file defining</span>
<span class="sd">    a set of regions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">regionNames</span><span class="p">,</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">_get_region_names_and_properties</span><span class="p">(</span><span class="n">fcMask</span><span class="p">)</span>

    <span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">nChar</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">fcMask</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;    </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">])</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="n">_katana</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">_compute_mask_from_shapes</span><span class="p">(</span>
            <span class="n">shapes1</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span> <span class="n">shapes2</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">_contains</span><span class="p">,</span>
            <span class="n">pool</span><span class="o">=</span><span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="o">=</span><span class="n">chunkSize</span><span class="p">,</span> <span class="n">showProgress</span><span class="o">=</span><span class="n">showProgress</span><span class="p">)</span>

        <span class="n">nChar</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nChar</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">regionNames</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">nChar</span>


<span class="k">def</span> <span class="nf">_contains</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">STRtree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
        <span class="n">indicesInShape</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s1">&#39;covers&#39;</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">indicesInShape</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">mask</span>


<span class="k">def</span> <span class="nf">_katana</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxcount</span><span class="o">=</span><span class="mi">250</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From https://snorfalorpagus.net/blog/2016/03/13/splitting-large-polygons-for-faster-intersections/</span>

<span class="sd">    Split a Polygon into two parts across it&#39;s shortest dimension</span>

<span class="sd">    Copyright (c) 2016, Joshua Arnott</span>

<span class="sd">    All rights reserved.</span>

<span class="sd">    Redistribution and use in source and binary forms, with or without</span>
<span class="sd">    modification, are permitted provided that the following conditions are met:</span>

<span class="sd">    1. Redistributions of source code must retain the above copyright notice,</span>
<span class="sd">       this list of conditions and the following disclaimer.</span>
<span class="sd">    2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="sd">       this list of conditions and the following disclaimer in the documentation</span>
<span class="sd">       and/or other materials provided with the distribution.</span>

<span class="sd">    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”</span>
<span class="sd">    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="sd">    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="sd">    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="sd">    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="sd">    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="sd">    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="sd">    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="sd">    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="sd">    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="sd">    POSSIBILITY OF SUCH DAMAGE.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">bounds</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">==</span> <span class="n">maxcount</span><span class="p">:</span>
        <span class="c1"># either the polygon is smaller than the threshold, or the maximum</span>
        <span class="c1"># number of recursions has been reached</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">geometry</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">height</span> <span class="o">&gt;=</span> <span class="n">width</span><span class="p">:</span>
        <span class="c1"># split left to right</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># split top to bottom</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">GeometryCollection</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">geoms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">)):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_katana</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxcount</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="c1"># convert multipart into singlepart</span>
    <span class="n">final_result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
            <span class="n">final_result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">geoms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">final_result</span>


<span class="k">def</span> <span class="nf">_compute_transect_masks</span><span class="p">(</span><span class="n">fcMask</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">,</span>
                            <span class="n">showProgress</span><span class="p">,</span> <span class="n">subdivisionResolution</span><span class="p">,</span> <span class="n">earthRadius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a transect mask file from the given mesh and geojson file defining</span>
<span class="sd">    a set of transects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">transectNames</span><span class="p">,</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">_get_region_names_and_properties</span><span class="p">(</span><span class="n">fcMask</span><span class="p">)</span>

    <span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">nChar</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">fcMask</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;    </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="n">geom_type</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">geom_type</span> <span class="o">==</span> <span class="s1">&#39;LineString&#39;</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">geom_type</span> <span class="o">==</span> <span class="s1">&#39;MultiLineString&#39;</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unexpected geometry type </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">geom_type</span><span class="p">))</span>

        <span class="n">new_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coord_index</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">subdivisionResolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">lon_lat_to_cartesian</span><span class="p">(</span>
                    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">earthRadius</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">subdivide_great_circle</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">subdivisionResolution</span><span class="p">,</span> <span class="n">earthRadius</span><span class="p">)</span>
                <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">cartesian_to_lon_lat</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">earthRadius</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">new_coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">geom_type</span> <span class="o">==</span> <span class="s1">&#39;LineString&#39;</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="n">new_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">MultiLineString</span><span class="p">(</span><span class="n">new_coords</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">_compute_mask_from_shapes</span><span class="p">(</span>
            <span class="n">shapes1</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">shapes2</span><span class="o">=</span><span class="n">polygons</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">_intersects</span><span class="p">,</span>
            <span class="n">pool</span><span class="o">=</span><span class="n">pool</span><span class="p">,</span> <span class="n">chunkSize</span><span class="o">=</span><span class="n">chunkSize</span><span class="p">,</span> <span class="n">showProgress</span><span class="o">=</span><span class="n">showProgress</span><span class="p">)</span>

        <span class="n">nChar</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nChar</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">transectNames</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">nChar</span><span class="p">,</span> <span class="n">shapes</span>


<span class="k">def</span> <span class="nf">_intersects</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">polygons</span><span class="p">):</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">STRtree</span><span class="p">(</span><span class="n">polygons</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polygons</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">indicesInShape</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s1">&#39;intersects&#39;</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">indicesInShape</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">mask</span>


<span class="k">def</span> <span class="nf">_get_polygons</span><span class="p">(</span><span class="n">dsMesh</span><span class="p">,</span> <span class="n">maskType</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">maskType</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
        <span class="c1"># polygons are vertices on cell</span>
        <span class="n">vertexIndices</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">verticesOnCell</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">nVerticesOnCell</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">nEdgesOnCell</span><span class="o">.</span><span class="n">values</span>
        <span class="n">maxVertices</span> <span class="o">=</span> <span class="n">vertexIndices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">iVertex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxVertices</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">iVertex</span> <span class="o">&gt;=</span> <span class="n">nVerticesOnCell</span>
            <span class="c1"># copy the last valid vertex</span>
            <span class="n">vertexIndices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">iVertex</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">vertexIndices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">nVerticesOnCell</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lonVertex</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">lonVertex</span><span class="o">.</span><span class="n">values</span>
        <span class="n">latVertex</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">latVertex</span><span class="o">.</span><span class="n">values</span>
        <span class="n">lonCenter</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">lonCell</span><span class="o">.</span><span class="n">values</span>
    <span class="k">elif</span> <span class="n">maskType</span> <span class="o">==</span> <span class="s1">&#39;vertex&#39;</span><span class="p">:</span>
        <span class="c1"># polygons are cells on vertex</span>
        <span class="n">vertexIndices</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">cellsOnVertex</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">maxVertices</span> <span class="o">=</span> <span class="n">vertexIndices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">firstValid</span> <span class="o">=</span> <span class="n">vertexIndices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">iVertex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxVertices</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">firstValid</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">firstValid</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexIndices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">iVertex</span><span class="p">]</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">firstValid</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">iVertex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxVertices</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">vertexIndices</span><span class="p">[:,</span> <span class="n">iVertex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">vertexIndices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">iVertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">firstValid</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">lonVertex</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">lonCell</span><span class="o">.</span><span class="n">values</span>
        <span class="n">latVertex</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">latCell</span><span class="o">.</span><span class="n">values</span>
        <span class="n">lonCenter</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">lonVertex</span><span class="o">.</span><span class="n">values</span>
    <span class="k">elif</span> <span class="n">maskType</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
        <span class="c1"># oh, dear, this is a bit more complicated.  Polygons are kites</span>
        <span class="c1"># involving both vertices and cell centers</span>
        <span class="n">verticesOnEdge</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">verticesOnEdge</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">cellsOnEdge</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">cellsOnEdge</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">nEdges</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;nEdges&#39;</span><span class="p">]</span>
        <span class="n">nCells</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;nCells&#39;</span><span class="p">]</span>
        <span class="n">vertexIndices</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nEdges</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">vertexIndices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cellsOnEdge</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">vertexIndices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">verticesOnEdge</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nCells</span>
        <span class="n">vertexIndices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cellsOnEdge</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">vertexIndices</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">verticesOnEdge</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nCells</span>

        <span class="c1"># if there are invalid cells, just point to the next vertex; all</span>
        <span class="c1"># vertices on cell should be valid</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">vertexIndices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">vertexIndices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexIndices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">vertexIndices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">vertexIndices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexIndices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

        <span class="n">lonVertex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dsMesh</span><span class="o">.</span><span class="n">lonCell</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                 <span class="n">dsMesh</span><span class="o">.</span><span class="n">lonVertex</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">latVertex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dsMesh</span><span class="o">.</span><span class="n">latCell</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                 <span class="n">dsMesh</span><span class="o">.</span><span class="n">latVertex</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="n">lonCenter</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">lonEdge</span><span class="o">.</span><span class="n">values</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown mask type </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">maskType</span><span class="p">))</span>

    <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">vertexIndices</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">latVertex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">latVertex</span><span class="p">)</span>
    <span class="c1"># transform longitudes to [-180, 180)</span>
    <span class="n">lonVertex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">lonVertex</span><span class="p">)</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">,</span> <span class="mf">360.</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.</span>
    <span class="n">lonCenter</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">lonCenter</span><span class="p">)</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">,</span> <span class="mf">360.</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.</span>

    <span class="n">lon</span> <span class="o">=</span> <span class="n">lonVertex</span><span class="p">[</span><span class="n">vertexIndices</span><span class="p">]</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">latVertex</span><span class="p">[</span><span class="n">vertexIndices</span><span class="p">]</span>

    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">duplicatePolygons</span> <span class="o">=</span> <span class="n">_copy_dateline_lon_lat_vertices</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span>
                                                                  <span class="n">lonCenter</span><span class="p">)</span>

    <span class="n">nPolygons</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lonCenter</span><span class="p">)</span>

    <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lon</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:],</span> <span class="n">lat</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">nPolygons</span><span class="p">,</span> <span class="n">duplicatePolygons</span>


<span class="k">def</span> <span class="nf">_copy_dateline_lon_lat_vertices</span><span class="p">(</span><span class="n">lonVertex</span><span class="p">,</span> <span class="n">latVertex</span><span class="p">,</span> <span class="n">lonCenter</span><span class="p">):</span>

    <span class="n">nPolygons</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lonVertex</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">lonDiff</span> <span class="o">=</span> <span class="n">lonVertex</span> <span class="o">-</span> <span class="n">lonCenter</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nPolygons</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># which polygons have vertices that are out of range to the west?</span>
    <span class="n">outOfRange</span> <span class="o">=</span> <span class="n">lonDiff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">180.</span>
    <span class="n">duplicatePolygonsEast</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">outOfRange</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">lonVertex</span><span class="p">[</span><span class="n">outOfRange</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">360.</span>
    <span class="n">lonVertexToAdd</span> <span class="o">=</span> <span class="n">lonVertex</span><span class="p">[</span><span class="n">duplicatePolygonsEast</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mf">360.</span>
    <span class="n">latVertexToAdd</span> <span class="o">=</span> <span class="n">latVertex</span><span class="p">[</span><span class="n">duplicatePolygonsEast</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># which polygons have vertices that are out of range to the east?</span>
    <span class="n">outOfRange</span> <span class="o">=</span> <span class="n">lonDiff</span> <span class="o">&gt;=</span> <span class="mf">180.</span>
    <span class="n">duplicatePolygonsWest</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">outOfRange</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">lonVertex</span><span class="p">[</span><span class="n">outOfRange</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">360.</span>
    <span class="n">lonVertexToAdd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lonVertexToAdd</span><span class="p">,</span>
                                  <span class="n">lonVertex</span><span class="p">[</span><span class="n">duplicatePolygonsWest</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mf">360.</span><span class="p">,</span>
                                  <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">latVertexToAdd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">latVertexToAdd</span><span class="p">,</span>
                                  <span class="n">latVertex</span><span class="p">[</span><span class="n">duplicatePolygonsWest</span><span class="p">,</span> <span class="p">:],</span>
                                  <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">lonVertex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lonVertex</span><span class="p">,</span> <span class="n">lonVertexToAdd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">latVertex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">latVertex</span><span class="p">,</span> <span class="n">latVertexToAdd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">duplicatePolygons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duplicatePolygonsEast</span><span class="p">,</span>
                                     <span class="n">duplicatePolygonsWest</span><span class="p">)</span>

    <span class="c1"># TODO: we still need to do something about cells that contain the poles</span>

    <span class="k">return</span> <span class="n">lonVertex</span><span class="p">,</span> <span class="n">latVertex</span><span class="p">,</span> <span class="n">duplicatePolygons</span>


<span class="k">def</span> <span class="nf">_compute_seed_mask</span><span class="p">(</span><span class="n">fcSeed</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">workers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the cell centers (points) closes to the given seed points and set</span>
<span class="sd">    the resulting mask to 1 there</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">fcSeed</span><span class="o">.</span><span class="n">features</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fcSeed</span><span class="o">.</span><span class="n">features</span><span class="p">):</span>
        <span class="n">points</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">mask</span>


<span class="k">def</span> <span class="nf">_flood_fill_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cellsOnCell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flood fill starting with a mask of seed points</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">maxNeighbors</span> <span class="o">=</span> <span class="n">cellsOnCell</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">cellsOnCell</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">maskCount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">iNeighbor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxNeighbors</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[:,</span> <span class="n">iNeighbor</span><span class="p">]</span>
            <span class="c1"># we only want to mask valid neighbors and locations that aren&#39;t</span>
            <span class="c1"># already masked</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">indices</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">localMask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">maskCount</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">localMask</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">localMask</span><span class="p">]</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">maskCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">mask</span>


<span class="k">def</span> <span class="nf">_compute_edge_sign</span><span class="p">(</span><span class="n">dsMesh</span><span class="p">,</span> <span class="n">edgeMask</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute the edge sign along a transect &quot;&quot;&quot;</span>

    <span class="n">edge_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">edgeMask</span><span class="p">)</span>
    <span class="n">voe</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">verticesOnEdge</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">nEdges</span><span class="o">=</span><span class="n">edge_indices</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dsMesh</span><span class="o">.</span><span class="n">lonVertex</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">voe</span><span class="p">])</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lon</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">,</span> <span class="mf">360.</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dsMesh</span><span class="o">.</span><span class="n">latVertex</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">voe</span><span class="p">])</span>

    <span class="n">lonEdge</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dsMesh</span><span class="o">.</span><span class="n">lonEdge</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">])</span>
    <span class="n">lonEdge</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lonEdge</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">,</span> <span class="mf">360.</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.</span>

    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">duplicate_edges</span> <span class="o">=</span> \
        <span class="n">_copy_dateline_lon_lat_vertices</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lonEdge</span><span class="p">)</span>

    <span class="n">nEdges</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;nEdges&#39;</span><span class="p">]</span>
    <span class="n">nVertices</span> <span class="o">=</span> <span class="n">dsMesh</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;nVertices&#39;</span><span class="p">]</span>

    <span class="c1"># give periodic copies unique edge and vertex indices</span>
    <span class="n">edge_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_indices</span><span class="p">,</span>
                                <span class="n">edge_indices</span><span class="p">[</span><span class="n">duplicate_edges</span><span class="p">]</span> <span class="o">+</span> <span class="n">nEdges</span><span class="p">)</span>

    <span class="n">voe</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">voe</span><span class="p">,</span> <span class="n">voe</span><span class="p">[</span><span class="n">duplicate_edges</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">nVertices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">unique_vertices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">voe</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

    <span class="n">local_voe</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">voe</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">unique_lon</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">unique_lat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">local_v</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_vertices</span><span class="p">):</span>
        <span class="n">local_mask</span> <span class="o">=</span> <span class="n">voe</span> <span class="o">==</span> <span class="n">v</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="n">local_mask</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="n">local_mask</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
        <span class="n">unique_lon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">unique_lat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">local_voe</span><span class="p">[</span><span class="n">local_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_v</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_vertices</span><span class="p">),</span>
                  <span class="n">edges</span><span class="o">=</span><span class="nb">zip</span><span class="p">(</span><span class="n">local_voe</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">local_voe</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_lon</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_lat</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_vertices</span><span class="p">))</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_indices</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span> <span class="k">for</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">voe</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">voe</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])]</span>

    <span class="n">edgeSign</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">edgeMask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">clusters</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cluster_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="n">clusters</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">cluster_index</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">es</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">es</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">source_vertex</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">edge</span><span class="o">.</span><span class="n">target_vertex</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> \
                <span class="n">cluster</span><span class="o">.</span><span class="n">get_shortest_paths</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;epath&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">es</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">source_vertex</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span> <span class="o">&lt;</span> \
                        <span class="n">edge</span><span class="o">.</span><span class="n">target_vertex</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">verts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">])</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verts</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]:</span>
                        <span class="n">sign</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">verts</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]:</span>
                        <span class="n">sign</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;could not find vertex &#39;</span>
                                         <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">verts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]:</span>
                    <span class="n">sign</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">verts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]:</span>
                    <span class="n">sign</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;could not find vertex -1&#39;</span><span class="p">)</span>

        <span class="n">sign</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sign</span><span class="p">)</span>
        <span class="n">edge_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">])</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nEdges</span>
        <span class="n">edgeSign</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">[</span><span class="n">valid</span><span class="p">]]</span> <span class="o">=</span> <span class="n">sign</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">duplicate</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span>
        <span class="n">edgeSign</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">[</span><span class="n">duplicate</span><span class="p">]</span> <span class="o">-</span> <span class="n">nEdges</span><span class="p">]</span> <span class="o">=</span> <span class="n">sign</span><span class="p">[</span><span class="n">duplicate</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">edgeSign</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright This software is open source software available under the BSD-3license. Copyright (c) 2019 Triad National Security, LLC. All rights reserved. Copyright (c) 2019 Lawrence Livermore National Security, LLC. All rights reserved. Copyright (c) 2019 UT-Battelle, LLC. All rights reserved..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>